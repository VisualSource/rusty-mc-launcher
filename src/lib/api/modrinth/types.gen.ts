// This file is auto-generated by @hey-api/openapi-ts

export type BaseVersion = {
  /**
   * The name of this version
   */
  name?: string;
  /**
   * The version number. Ideally will follow semantic versioning
   */
  version_number?: string;
  /**
   * The changelog for this version
   */
  changelog?: string | null;
  /**
   * A list of specific versions of projects that this version depends on
   */
  dependencies?: Array<VersionDependency>;
  /**
   * A list of versions of Minecraft that this version supports
   */
  game_versions?: Array<string>;
  /**
   * The release channel for this version
   */
  version_type?: "release" | "beta" | "alpha";
  /**
   * The mod loaders that this version supports
   */
  loaders?: Array<string>;
  /**
   * Whether the version is featured or not
   */
  featured?: boolean;
  status?:
    | "listed"
    | "archived"
    | "draft"
    | "unlisted"
    | "scheduled"
    | "unknown";
  requested_status?: "listed" | "archived" | "draft" | "unlisted" | null;
};

export type VersionDependency = {
  /**
   * The ID of the version that this version depends on
   */
  version_id?: string | null;
  /**
   * The ID of the project that this version depends on
   */
  project_id?: string | null;
  /**
   * The file name of the dependency, mostly used for showing external dependencies on modpacks
   */
  file_name?: string | null;
  /**
   * The type of dependency that this version has
   */
  dependency_type: "required" | "optional" | "incompatible" | "embedded";
};

export type EditableVersion = BaseVersion & {
  /**
   * The hash format and the hash of the new primary file
   */
  primary_file?: Array<string>;
  /**
   * A list of file_types to edit
   */
  file_types?: Array<EditableFileType>;
};

export type EditableFileType = {
  /**
   * The hash algorithm of the hash specified in the hash field
   */
  algorithm: string;
  /**
   * The hash of the file you're editing
   */
  hash: string;
  /**
   * The hash algorithm of the file you're editing
   */
  file_type: "required-resource-pack" | "optional-resource-pack" | null;
};

export type CreatableVersion = BaseVersion & {
  /**
   * The ID of the project this version is for
   */
  project_id: string;
  /**
   * An array of the multipart field names of each file that goes with this version
   */
  file_parts: Array<string>;
  /**
   * The multipart field name of the primary file
   */
  primary_file?: string;
};

export type CreateVersionBody = {
  data: CreatableVersion;
};

export type Version = BaseVersion & {
  /**
   * The ID of the version, encoded as a base62 string
   */
  id: string;
  /**
   * The ID of the project this version is for
   */
  project_id: string;
  /**
   * The ID of the author who published this version
   */
  author_id: string;
  date_published: string;
  /**
   * The number of times this version has been downloaded
   */
  downloads: number;
  /**
   * A link to the changelog for this version. Always null, only kept for legacy compatibility.
   * @deprecated
   */
  changelog_url?: string | null;
  /**
   * A list of files available for download for this version
   */
  files: Array<VersionFile>;
};

export type VersionFile = {
  hashes: VersionFileHashes;
  /**
   * A direct link to the file
   */
  url: string;
  /**
   * The name of the file
   */
  filename: string;
  /**
   * Whether this file is the primary one for its version. Only a maximum of one file per version will have this set to true. If there are not any primary files, it can be inferred that the first file is the primary one.
   */
  primary: boolean;
  /**
   * The size of the file in bytes
   */
  size: number;
  /**
   * The type of the additional file, used mainly for adding resource packs to datapacks
   */
  file_type?: "required-resource-pack" | "optional-resource-pack" | null;
};

/**
 * A map of hashes of the file. The key is the hashing algorithm and the value is the string version of the hash.
 */
export type VersionFileHashes = {
  sha512?: string;
  sha1?: string;
};

export type GetLatestVersionFromHashBody = {
  loaders: Array<string>;
  game_versions: Array<string>;
};

/**
 * A map from hashes to versions
 */
export type HashVersionMap = {
  [key: string]: Version;
};

/**
 * A list of hashes and the algorithm used to create them
 */
export type HashList = {
  hashes: Array<string>;
  algorithm: "sha1" | "sha512";
};

export type GetLatestVersionsFromHashesBody = HashList & {
  loaders: Array<string>;
  game_versions: Array<string>;
};

export type BaseProject = {
  /**
   * The slug of a project, used for vanity URLs. Regex: ```^[\w!@$()`.+,"\-']{3,64}$```
   */
  slug?: string;
  /**
   * The title or name of the project
   */
  title?: string;
  /**
   * A short description of the project
   */
  description?: string;
  /**
   * A list of the categories that the project has
   */
  categories?: Array<string>;
  /**
   * The client side support of the project
   */
  client_side?: "required" | "optional" | "unsupported";
  /**
   * The server side support of the project
   */
  server_side?: "required" | "optional" | "unsupported";
};

export type ServerRenderedProject = BaseProject & {
  /**
   * The project type of the project
   */
  project_type: "mod" | "modpack" | "resourcepack" | "shader";
  /**
   * The total number of downloads of the project
   */
  downloads: number;
  /**
   * The URL of the project's icon
   */
  icon_url?: string | null;
  /**
   * The RGB color of the project, automatically generated from the project icon
   */
  color?: number | null;
  /**
   * The ID of the moderation thread associated with this project
   */
  thread_id?: string;
  monetization_status?: "monetized" | "demonetized" | "force-demonetized";
};

export type ProjectResult = ServerRenderedProject & {
  /**
   * The ID of the project
   */
  project_id: string;
  /**
   * The username of the project's author
   */
  author: string;
  /**
   * A list of the categories that the project has which are not secondary
   */
  display_categories?: Array<string>;
  /**
   * A list of the minecraft versions supported by the project
   */
  versions: Array<string>;
  /**
   * The total number of users following the project
   */
  follows: number;
  /**
   * The date the project was added to search
   */
  date_created: string;
  /**
   * The date the project was last modified
   */
  date_modified: string;
  /**
   * The latest version of minecraft that this project supports
   */
  latest_version?: string;
  /**
   * The SPDX license ID of a project
   */
  license: string;
  /**
   * All gallery images attached to the project
   */
  gallery?: Array<string>;
  /**
   * The featured gallery image of the project
   */
  featured_gallery?: string | null;
};

export type NonSearchProject = BaseProject & {
  /**
   * A long form description of the project
   */
  body?: string;
  /**
   * The status of the project
   */
  status?:
    | "approved"
    | "archived"
    | "rejected"
    | "draft"
    | "unlisted"
    | "processing"
    | "withheld"
    | "scheduled"
    | "private"
    | "unknown";
  /**
   * The requested status when submitting for review or scheduling the project for release
   */
  requested_status?:
    | "approved"
    | "archived"
    | "unlisted"
    | "private"
    | "draft"
    | null;
  /**
   * A list of categories which are searchable but non-primary
   */
  additional_categories?: Array<string>;
  /**
   * An optional link to where to submit bugs or issues with the project
   */
  issues_url?: string | null;
  /**
   * An optional link to the source code of the project
   */
  source_url?: string | null;
  /**
   * An optional link to the project's wiki page or other relevant information
   */
  wiki_url?: string | null;
  /**
   * An optional invite link to the project's discord
   */
  discord_url?: string | null;
  /**
   * A list of donation links for the project
   */
  donation_urls?: Array<ProjectDonationURL>;
};

export type ProjectDonationURL = {
  /**
   * The ID of the donation platform
   */
  id?: string;
  /**
   * The donation platform this link is to
   */
  platform?: string;
  /**
   * The URL of the donation platform and user
   */
  url?: string;
};

export type ModifiableProject = NonSearchProject & {
  /**
   * The SPDX license ID of a project
   */
  license_id?: string;
  /**
   * The URL to this license
   */
  license_url?: string | null;
};

export type EditableProject = ModifiableProject & {
  /**
   * The title of the moderators' message for the project
   */
  moderation_message?: string | null;
  /**
   * The body of the moderators' message for the project
   */
  moderation_message_body?: string | null;
};

export type CreatableProject = ModifiableProject & {
  project_type: "mod" | "modpack";
  /**
   * A list of initial versions to upload with the created project. Deprecated - please upload version files after initial upload.
   * @deprecated
   */
  initial_versions?: Array<EditableVersion>;
  /**
   * Whether the project should be saved as a draft instead of being sent to moderation for review. Deprecated - please always mark this as true.
   * @deprecated
   */
  is_draft?: boolean;
  /**
   * Gallery images to be uploaded with the created project. Deprecated - please upload gallery images after initial upload.
   * @deprecated
   */
  gallery_items?: Array<CreatableProjectGalleryItem>;
};

export type CreatableProjectGalleryItem = {
  /**
   * The name of the multipart item where the gallery media is located
   */
  item?: string;
  /**
   * Whether the image is featured in the gallery
   */
  featured?: boolean;
  /**
   * The title of the gallery image
   */
  title?: string | null;
  /**
   * The description of the gallery image
   */
  description?: string | null;
  /**
   * The order of the gallery image. Gallery images are sorted by this field and then alphabetically by title.
   */
  ordering?: number;
} | null;

export type Project = NonSearchProject &
  ServerRenderedProject & {
    /**
     * The ID of the project, encoded as a base62 string
     */
    id: string;
    /**
     * The ID of the team that has ownership of this project
     */
    team: string;
    /**
     * The link to the long description of the project. Always null, only kept for legacy compatibility.
     * @deprecated
     */
    body_url?: string | null;
    moderator_message?: ModeratorMessage;
    /**
     * The date the project was published
     */
    published: string;
    /**
     * The date the project was last updated
     */
    updated: string;
    /**
     * The date the project's status was set to an approved status
     */
    approved?: string | null;
    /**
     * The date the project's status was submitted to moderators for review
     */
    queued?: string | null;
    /**
     * The total number of users following the project
     */
    followers: number;
    license?: ProjectLicense;
    /**
     * A list of the version IDs of the project (will never be empty unless `draft` status)
     */
    versions?: Array<string>;
    /**
     * A list of all of the game versions supported by the project
     */
    game_versions?: Array<string>;
    /**
     * A list of all of the loaders supported by the project
     */
    loaders?: Array<string>;
    /**
     * A list of images that have been uploaded to the project's gallery
     */
    gallery?: Array<GalleryImage>;
  };

/**
 * A message that a moderator sent regarding the project
 * @deprecated
 */
export type ModeratorMessage = {
  /**
   * The message that a moderator has left for the project
   */
  message?: string;
  /**
   * The longer body of the message that a moderator has left for the project
   */
  body?: string | null;
} | null;

/**
 * The license of the project
 */
export type ProjectLicense = {
  /**
   * The SPDX license ID of a project
   */
  id?: string;
  /**
   * The long name of a license
   */
  name?: string;
  /**
   * The URL to this license
   */
  url?: string | null;
};

export type GalleryImage = {
  /**
   * The URL of the gallery image
   */
  url: string;
  /**
   * Whether the image is featured in the gallery
   */
  featured: boolean;
  /**
   * The title of the gallery image
   */
  title?: string | null;
  /**
   * The description of the gallery image
   */
  description?: string | null;
  /**
   * The date and time the gallery image was created
   */
  created: string;
  /**
   * The order of the gallery image. Gallery images are sorted by this field and then alphabetically by title.
   */
  ordering?: number;
} | null;

export type ProjectDependencyList = {
  /**
   * Projects that the project depends upon
   */
  projects?: Array<Project>;
  /**
   * Versions that the project depends upon
   */
  versions?: Array<Version>;
};

export type PatchProjectsBody = {
  /**
   * Set all of the categories to the categories specified here
   */
  categories?: Array<string>;
  /**
   * Add all of the categories specified here
   */
  add_categories?: Array<string>;
  /**
   * Remove all of the categories specified here
   */
  remove_categories?: Array<string>;
  /**
   * Set all of the additional categories to the categories specified here
   */
  additional_categories?: Array<string>;
  /**
   * Add all of the additional categories specified here
   */
  add_additional_categories?: Array<string>;
  /**
   * Remove all of the additional categories specified here
   */
  remove_additional_categories?: Array<string>;
  /**
   * Set all of the donation links to the donation links specified here
   */
  donation_urls?: Array<ProjectDonationURL>;
  /**
   * Add all of the donation links specified here
   */
  add_donation_urls?: Array<ProjectDonationURL>;
  /**
   * Remove all of the donation links specified here
   */
  remove_donation_urls?: Array<ProjectDonationURL>;
  /**
   * An optional link to where to submit bugs or issues with the projects
   */
  issues_url?: string | null;
  /**
   * An optional link to the source code of the projects
   */
  source_url?: string | null;
  /**
   * An optional link to the projects' wiki page or other relevant information
   */
  wiki_url?: string | null;
  /**
   * An optional invite link to the projects' discord
   */
  discord_url?: string | null;
};

export type CreateProjectBody = {
  data: CreatableProject;
  /**
   * Project icon file
   */
  icon?:
    | "*.png"
    | "*.jpg"
    | "*.jpeg"
    | "*.bmp"
    | "*.gif"
    | "*.webp"
    | "*.svg"
    | "*.svgz"
    | "*.rgb";
};

export type ProjectIdentifier = {
  id?: string;
};

export type Schedule = {
  time: string;
  /**
   * The requested status when scheduling the project for release
   */
  requested_status: "approved" | "archived" | "unlisted" | "private" | "draft";
};

export type SearchResults = {
  /**
   * The list of results
   */
  hits: Array<ProjectResult>;
  /**
   * The number of results that were skipped by the query
   */
  offset: number;
  /**
   * The number of results that were returned by the query
   */
  limit: number;
  /**
   * The total number of results that match the query
   */
  total_hits: number;
};

export type UserIdentifier = {
  user_id: string;
};

export type EditableUser = {
  /**
   * The user's username
   */
  username: string;
  /**
   * The user's display name
   */
  name?: string | null;
  /**
   * The user's email (only displayed if requesting your own account). Requires `USER_READ_EMAIL` PAT scope.
   */
  email?: string | null;
  /**
   * A description of the user
   */
  bio?: string;
  payout_data?: UserPayoutData;
};

/**
 * Various data relating to the user's payouts status (you can only see your own)
 */
export type UserPayoutData = {
  /**
   * The payout balance available for the user to withdraw (note, you cannot modify this in a PATCH request)
   */
  balance?: number;
  /**
   * The wallet that the user has selected
   */
  payout_wallet?: "paypal" | "venmo";
  /**
   * The type of the user's wallet
   */
  payout_wallet_type?: "email" | "phone" | "user_handle";
  /**
   * The user's payout address
   */
  payout_address?: string;
} | null;

export type User = EditableUser & {
  /**
   * The user's ID
   */
  id: string;
  /**
   * The user's avatar url
   */
  avatar_url: string;
  /**
   * The time at which the user was created
   */
  created: string;
  /**
   * The user's role
   */
  role: "admin" | "moderator" | "developer";
  /**
   * Any badges applicable to this user. These are currently unused and undisplayed, and as such are subject to change
   *
   * In order from first to seventh bit, the current bits are:
   * - (unused)
   * - EARLY_MODPACK_ADOPTER
   * - EARLY_RESPACK_ADOPTER
   * - EARLY_PLUGIN_ADOPTER
   * - ALPHA_TESTER
   * - CONTRIBUTOR
   * - TRANSLATOR
   *
   */
  badges?: number;
  /**
   * A list of authentication providers you have signed up for (only displayed if requesting your own account)
   */
  auth_providers?: Array<string> | null;
  /**
   * Whether your email is verified (only displayed if requesting your own account)
   */
  email_verified?: boolean | null;
  /**
   * Whether you have a password associated with your account (only displayed if requesting your own account)
   */
  has_password?: boolean | null;
  /**
   * Whether you have TOTP two-factor authentication connected to your account (only displayed if requesting your own account)
   */
  has_totp?: boolean | null;
  /**
   * Deprecated - this is no longer public for security reasons and is always null
   * @deprecated
   */
  github_id?: number | null;
};

export type UserPayoutHistory = {
  /**
   * The all-time balance accrued by this user in USD
   */
  all_time?: string;
  /**
   * The amount in USD made by the user in the previous 30 days
   */
  last_month?: string;
  /**
   * A history of all of the user's past transactions
   */
  payouts?: Array<UserPayoutHistoryEntry>;
};

export type UserPayoutHistoryEntry = {
  /**
   * The date of this transaction
   */
  created?: string;
  /**
   * The amount of this transaction in USD
   */
  amount?: number;
  /**
   * The status of this transaction
   */
  status?: string;
};

export type Notification = {
  /**
   * The id of the notification
   */
  id: string;
  /**
   * The id of the user who received the notification
   */
  user_id: string;
  /**
   * The type of notification
   */
  type?:
    | "project_update"
    | "team_invite"
    | "status_change"
    | "moderator_message"
    | null;
  /**
   * The title of the notification
   */
  title: string;
  /**
   * The body text of the notification
   */
  text: string;
  /**
   * A link to the related project or version
   */
  link: string;
  /**
   * Whether the notification has been read or not
   */
  read: boolean;
  /**
   * The time at which the notification was created
   */
  created: string;
  /**
   * A list of actions that can be performed
   */
  actions: Array<NotificationAction>;
};

/**
 * An action that can be performed on a notification
 */
export type NotificationAction = {
  /**
   * The friendly name for this action
   */
  title?: string;
  /**
   * The HTTP code and path to request in order to perform this action.
   */
  action_route?: Array<string>;
};

export type CreatableReport = {
  /**
   * The type of the report being sent
   */
  report_type: string;
  /**
   * The ID of the item (project, version, or user) being reported
   */
  item_id: string;
  /**
   * The type of the item being reported
   */
  item_type: "project" | "user" | "version";
  /**
   * The extended explanation of the report
   */
  body: string;
};

export type Report = CreatableReport & {
  /**
   * The ID of the report
   */
  id?: string;
  /**
   * The ID of the user who reported the item
   */
  reporter: string;
  /**
   * The time at which the report was created
   */
  created: string;
  /**
   * Whether the report is resolved
   */
  closed: boolean;
  /**
   * The ID of the moderation thread associated with this report
   */
  thread_id: string;
};

export type Thread = {
  /**
   * The ID of the thread
   */
  id: string;
  type: "project" | "report" | "direct_message";
  /**
   * The ID of the associated project if a project thread
   */
  project_id?: string | null;
  /**
   * The ID of the associated report if a report thread
   */
  report_id?: string | null;
  messages: Array<ThreadMessage>;
  members: Array<User>;
};

export type ThreadMessage = {
  /**
   * The ID of the message itself
   */
  id: string;
  /**
   * The ID of the author
   */
  author_id?: string | null;
  body: ThreadMessageBody;
  /**
   * The time at which the message was created
   */
  created: string;
};

/**
 * The contents of the message. **Fields will vary depending on message type.**
 */
export type ThreadMessageBody = {
  /**
   * The type of message
   */
  type: "status_change" | "text" | "thread_closure" | "deleted";
  /**
   * The actual message text. **Only present for `text` message type**
   */
  body?: string;
  /**
   * Whether the message is only visible to moderators. **Only present for `text` message type**
   */
  private?: boolean;
  /**
   * The ID of the message being replied to by this message. **Only present for `text` message type**
   */
  replying_to?: string | null;
  /**
   * The old status of the project. **Only present for `status_change` message type**
   */
  old_status?:
    | "approved"
    | "archived"
    | "rejected"
    | "draft"
    | "unlisted"
    | "processing"
    | "withheld"
    | "scheduled"
    | "private"
    | "unknown";
  /**
   * The new status of the project. **Only present for `status_change` message type**
   */
  new_status?:
    | "approved"
    | "archived"
    | "rejected"
    | "draft"
    | "unlisted"
    | "processing"
    | "withheld"
    | "scheduled"
    | "private"
    | "unknown";
};

export type TeamMember = {
  /**
   * The ID of the team this team member is a member of
   */
  team_id: string;
  user: User;
  /**
   * The user's role on the team
   */
  role: string;
  /**
   * The user's permissions in bitfield format (requires authorization to view)
   *
   * In order from first to tenth bit, the bits are:
   * - UPLOAD_VERSION
   * - DELETE_VERSION
   * - EDIT_DETAILS
   * - EDIT_BODY
   * - MANAGE_INVITES
   * - REMOVE_MEMBER
   * - EDIT_MEMBER
   * - DELETE_PROJECT
   * - VIEW_ANALYTICS
   * - VIEW_PAYOUTS
   *
   */
  permissions?: number;
  /**
   * Whether or not the user has accepted to be on the team (requires authorization to view)
   */
  accepted: boolean;
  /**
   * The split of payouts going to this user. The proportion of payouts they get is their split divided by the sum of the splits of all members.
   */
  payouts_split?: number;
  /**
   * The order of the team member.
   */
  ordering?: number;
};

export type CategoryTag = {
  /**
   * The SVG icon of a category
   */
  icon: string;
  /**
   * The name of the category
   */
  name: string;
  /**
   * The project type this category is applicable to
   */
  project_type: string;
  /**
   * The header under which the category should go
   */
  header: string;
};

export type LoaderTag = {
  /**
   * The SVG icon of a loader
   */
  icon: string;
  /**
   * The name of the loader
   */
  name: string;
  /**
   * The project types that this loader is applicable to
   */
  supported_project_types: Array<string>;
};

export type GameVersionTag = {
  /**
   * The name/number of the game version
   */
  version: string;
  /**
   * The type of the game version
   */
  version_type: "release" | "snapshot" | "alpha" | "beta";
  /**
   * The date of the game version release
   */
  date: string;
  /**
   * Whether or not this is a major version, used for Featured Versions
   */
  major: boolean;
};

export type DonationPlatformTag = {
  /**
   * The short identifier of the donation platform
   */
  short: string;
  /**
   * The full name of the donation platform
   */
  name: string;
};

export type ModifyTeamMemberBody = {
  role?: string;
  /**
   * The user's permissions in bitfield format
   *
   * In order from first to tenth bit, the bits are:
   * - UPLOAD_VERSION
   * - DELETE_VERSION
   * - EDIT_DETAILS
   * - EDIT_BODY
   * - MANAGE_INVITES
   * - REMOVE_MEMBER
   * - EDIT_MEMBER
   * - DELETE_PROJECT
   * - VIEW_ANALYTICS
   * - VIEW_PAYOUTS
   *
   */
  permissions?: number;
  /**
   * The split of payouts going to this user. The proportion of payouts they get is their split divided by the sum of the splits of all members.
   */
  payouts_split?: number;
  /**
   * The order of the team member.
   */
  ordering?: number;
};

/**
 * A short overview of a license
 */
export type LicenseTag = {
  /**
   * The short identifier of the license
   */
  short: string;
  /**
   * The full name of the license
   */
  name: string;
};

/**
 * A full license
 */
export type License = {
  title?: string;
  body?: string;
};

export type InvalidInputError = {
  /**
   * The name of the error
   */
  error: string;
  /**
   * The contents of the error
   */
  description: string;
};

export type AuthError = {
  /**
   * The name of the error
   */
  error: string;
  /**
   * The contents of the error
   */
  description: string;
};

export type Statistics = {
  /**
   * Number of projects on Modrinth
   */
  projects?: number;
  /**
   * Number of projects on Modrinth
   */
  versions?: number;
  /**
   * Number of version files on Modrinth
   */
  files?: number;
  /**
   * Number of authors (users with projects) on Modrinth
   */
  authors?: number;
};

/**
 * Mod version information that can be consumed by Forge's update checker
 */
export type ForgeUpdates = {
  /**
   * A link to the mod page
   */
  homepage?: string;
  promos?: ForgeUpdateCheckerPromos;
};

/**
 * A list of the recommended and latest versions for each Minecraft release
 */
export type ForgeUpdateCheckerPromos = {
  /**
   * The mod version that is recommended for `{version}`. Excludes versions with the `alpha` and `beta` version types.
   */
  "{version}-recommended"?: string;
  /**
   * The latest mod version for `{version}`. Shows versions with the `alpha` and `beta` version types.
   */
  "{version}-latest"?: string;
};

/**
 * The ID or slug of the project
 */
export type ParameterProjectIdentifier = string;

/**
 * The IDs and/or slugs of the projects
 */
export type ParameterMultipleProjectIdentifier = string;

/**
 * The ID or username of the user
 */
export type ParameterUserIdentifier = string;

/**
 * The ID of the version
 */
export type ParameterVersionIdentifier = string;

/**
 * The ID of the team
 */
export type ParameterTeamIdentifier = string;

/**
 * The ID of the report
 */
export type ParameterReportIdentifier = string;

/**
 * The ID of the thread
 */
export type ParameterThreadIdentifier = string;

/**
 * The ID of the notification
 */
export type ParameterNotificationIdentifier = string;

/**
 * The algorithm of the hash
 */
export type ParameterAlgorithmIdentifier = "sha1" | "sha512";

/**
 * Whether to return multiple results when looking for this hash
 */
export type ParameterMultipleHashQueryIdentifier = boolean;

/**
 * The hash of the file, considering its byte content, and encoded in hexadecimal
 */
export type ParameterFileHashIdentifier = string;

export type SearchProjectsData = {
  /**
   * Facets are an essential concept for understanding how to filter out results.
   *
   * These are the most commonly used facet types:
   * - `project_type`
   * - `categories` (loaders are lumped in with categories in search)
   * - `versions`
   * - `client_side`
   * - `server_side`
   * - `open_source`
   *
   * Several others are also available for use, though these should not be used outside very specific use cases.
   * - `title`
   * - `author`
   * - `follows`
   * - `project_id`
   * - `license`
   * - `downloads`
   * - `color`
   * - `created_timestamp`
   * - `modified_timestamp`
   *
   * In order to then use these facets, you need a value to filter by, as well as an operation to perform on this value.
   * The most common operation is `:` (same as `=`), though you can also use `!=`, `>=`, `>`, `<=`, and `<`.
   * Join together the type, operation, and value, and you've got your string.
   * ```
   * {type} {operation} {value}
   * ```
   *
   * Examples:
   * ```
   * categories = adventure
   * versions != 1.20.1
   * downloads <= 100
   * ```
   *
   * You then join these strings together in arrays to signal `AND` and `OR` operators.
   *
   * ##### OR
   * All elements in a single array are considered to be joined by OR statements.
   * For example, the search `[["versions:1.16.5", "versions:1.17.1"]]` translates to `Projects that support 1.16.5 OR 1.17.1`.
   *
   * ##### AND
   * Separate arrays are considered to be joined by AND statements.
   * For example, the search `[["versions:1.16.5"], ["project_type:modpack"]]` translates to `Projects that support 1.16.5 AND are modpacks`.
   *
   */
  facets?: string;
  /**
   * The sorting method used for sorting search results
   */
  index?: "relevance" | "downloads" | "follows" | "newest" | "updated";
  /**
   * The number of results returned by the search
   */
  limit?: number;
  /**
   * The offset into the search. Skips this number of results
   */
  offset?: number;
  /**
   * The query to search for
   */
  query?: string;
};

export type SearchProjectsResponse = SearchResults;

export type GetProjectData = {
  /**
   * The ID or slug of the project
   */
  idSlug: string;
};

export type GetProjectResponse = Project;

export type ModifyProjectData = {
  /**
   * The ID or slug of the project
   */
  idSlug: string;
  /**
   * Modified project fields
   */
  requestBody?: EditableProject;
};

export type ModifyProjectResponse = void;

export type DeleteProjectData = {
  /**
   * The ID or slug of the project
   */
  idSlug: string;
};

export type DeleteProjectResponse = void;

export type GetProjectsData = {
  /**
   * The IDs and/or slugs of the projects
   */
  ids: string;
};

export type GetProjectsResponse = Array<Project>;

export type PatchProjectsData = {
  /**
   * The IDs and/or slugs of the projects
   */
  ids: string;
  /**
   * Fields to edit on all projects specified
   */
  requestBody?: PatchProjectsBody;
};

export type PatchProjectsResponse = void;

export type RandomProjectsData = {
  /**
   * The number of random projects to return
   */
  count: number;
};

export type RandomProjectsResponse = Array<Project>;

export type CreateProjectData = {
  /**
   * New project
   */
  formData?: CreateProjectBody;
};

export type CreateProjectResponse = Project;

export type ChangeProjectIconData = {
  /**
   * Image extension
   */
  ext: "png" | "jpg" | "jpeg" | "bmp" | "gif" | "webp" | "svg" | "svgz" | "rgb";
  /**
   * The ID or slug of the project
   */
  idSlug: string;
  requestBody?: Blob | File;
};

export type ChangeProjectIconResponse = void;

export type DeleteProjectIconData = {
  /**
   * The ID or slug of the project
   */
  idSlug: string;
};

export type DeleteProjectIconResponse = void;

export type CheckProjectValidityData = {
  /**
   * The ID or slug of the project
   */
  idSlug: string;
};

export type CheckProjectValidityResponse = ProjectIdentifier;

export type AddGalleryImageData = {
  /**
   * Description of the image
   */
  description?: string;
  /**
   * Image extension
   */
  ext: "png" | "jpg" | "jpeg" | "bmp" | "gif" | "webp" | "svg" | "svgz" | "rgb";
  /**
   * Whether an image is featured
   */
  featured: boolean;
  /**
   * The ID or slug of the project
   */
  idSlug: string;
  /**
   * Ordering of the image
   */
  ordering?: number;
  requestBody?: Blob | File;
  /**
   * Title of the image
   */
  title?: string;
};

export type AddGalleryImageResponse = void;

export type ModifyGalleryImageData = {
  /**
   * New description of the image
   */
  description?: string;
  /**
   * Whether the image is featured
   */
  featured?: boolean;
  /**
   * The ID or slug of the project
   */
  idSlug: string;
  /**
   * New ordering of the image
   */
  ordering?: number;
  /**
   * New title of the image
   */
  title?: string;
  /**
   * URL link of the image to modify
   */
  url: string;
};

export type ModifyGalleryImageResponse = void;

export type DeleteGalleryImageData = {
  /**
   * The ID or slug of the project
   */
  idSlug: string;
  /**
   * URL link of the image to delete
   */
  url: string;
};

export type DeleteGalleryImageResponse = void;

export type GetDependenciesData = {
  /**
   * The ID or slug of the project
   */
  idSlug: string;
};

export type GetDependenciesResponse = ProjectDependencyList;

export type FollowProjectData = {
  /**
   * The ID or slug of the project
   */
  idSlug: string;
};

export type FollowProjectResponse = void;

export type UnfollowProjectData = {
  /**
   * The ID or slug of the project
   */
  idSlug: string;
};

export type UnfollowProjectResponse = void;

export type ScheduleProjectData = {
  /**
   * The ID or slug of the project
   */
  idSlug: string;
  /**
   * Information about date and requested status
   */
  requestBody?: Schedule;
};

export type ScheduleProjectResponse = void;

export type GetProjectVersionsData = {
  /**
   * Allows to filter for featured or non-featured versions only
   */
  featured?: boolean;
  /**
   * The game versions to filter for
   */
  gameVersions?: string;
  /**
   * The ID or slug of the project
   */
  idSlug: string;
  /**
   * The types of loaders to filter for
   */
  loaders?: string;
};

export type GetProjectVersionsResponse = Array<Version>;

export type GetVersionData = {
  /**
   * The ID of the version
   */
  id: string;
};

export type GetVersionResponse = Version;

export type ModifyVersionData = {
  /**
   * The ID of the version
   */
  id: string;
  /**
   * Modified version fields
   */
  requestBody?: EditableVersion;
};

export type ModifyVersionResponse = void;

export type DeleteVersionData = {
  /**
   * The ID of the version
   */
  id: string;
};

export type DeleteVersionResponse = void;

export type GetVersionFromIdOrNumberData = {
  /**
   * The version ID or version number
   */
  idNumber: string;
  /**
   * The ID or slug of the project
   */
  idSlug: string;
};

export type GetVersionFromIdOrNumberResponse = Version;

export type CreateVersionData = {
  /**
   * New version
   */
  formData?: CreateVersionBody;
};

export type CreateVersionResponse = Version;

export type ScheduleVersionData = {
  /**
   * The ID of the version
   */
  id: string;
  /**
   * Information about date and requested status
   */
  requestBody?: Schedule;
};

export type ScheduleVersionResponse = void;

export type GetVersionsData = {
  /**
   * The IDs of the versions
   */
  ids: string;
};

export type GetVersionsResponse = Array<Version>;

export type AddFilesToVersionData = {
  /**
   * New version files
   */
  formData?: {
    data?: {
      [key: string]: unknown;
    };
  };
  /**
   * The ID of the version
   */
  id: string;
};

export type AddFilesToVersionResponse = void;

export type VersionFromHashData = {
  /**
   * The algorithm of the hash
   */
  algorithm: "sha1" | "sha512";
  /**
   * The hash of the file, considering its byte content, and encoded in hexadecimal
   */
  hash: string;
  /**
   * Whether to return multiple results when looking for this hash
   */
  multiple?: boolean;
};

export type VersionFromHashResponse = Version;

export type DeleteFileFromHashData = {
  /**
   * The algorithm of the hash
   */
  algorithm: "sha1" | "sha512";
  /**
   * The hash of the file, considering its byte content, and encoded in hexadecimal
   */
  hash: string;
  /**
   * Version ID to delete the version from, if multiple files of the same hash exist
   */
  versionId?: string;
};

export type DeleteFileFromHashResponse = void;

export type GetLatestVersionFromHashData = {
  /**
   * The algorithm of the hash
   */
  algorithm: "sha1" | "sha512";
  /**
   * The hash of the file, considering its byte content, and encoded in hexadecimal
   */
  hash: string;
  /**
   * Parameters of the updated version requested
   */
  requestBody?: GetLatestVersionFromHashBody;
};

export type GetLatestVersionFromHashResponse = Version;

export type VersionsFromHashesData = {
  /**
   * Hashes and algorithm of the versions requested
   */
  requestBody?: HashList;
};

export type VersionsFromHashesResponse = HashVersionMap;

export type GetLatestVersionsFromHashesData = {
  /**
   * Parameters of the updated version requested
   */
  requestBody?: GetLatestVersionsFromHashesBody;
};

export type GetLatestVersionsFromHashesResponse = HashVersionMap;

export type GetUserData = {
  /**
   * The ID or username of the user
   */
  idUsername: string;
};

export type GetUserResponse = User;

export type ModifyUserData = {
  /**
   * The ID or username of the user
   */
  idUsername: string;
  /**
   * Modified user fields
   */
  requestBody?: EditableUser;
};

export type ModifyUserResponse = void;

export type GetUserFromAuthResponse = User;

export type GetUsersData = {
  /**
   * The IDs of the users
   */
  ids: string;
};

export type GetUsersResponse = Array<User>;

export type ChangeUserIconData = {
  /**
   * The ID or username of the user
   */
  idUsername: string;
  requestBody?: Blob | File;
};

export type ChangeUserIconResponse = void;

export type GetUserProjectsData = {
  /**
   * The ID or username of the user
   */
  idUsername: string;
};

export type GetUserProjectsResponse = Array<Project>;

export type GetFollowedProjectsData = {
  /**
   * The ID or username of the user
   */
  idUsername: string;
};

export type GetFollowedProjectsResponse = Array<Project>;

export type GetPayoutHistoryData = {
  /**
   * The ID or username of the user
   */
  idUsername: string;
};

export type GetPayoutHistoryResponse = UserPayoutHistory;

export type WithdrawPayoutData = {
  /**
   * Amount to withdraw
   */
  amount: number;
  /**
   * The ID or username of the user
   */
  idUsername: string;
};

export type WithdrawPayoutResponse = void;

export type GetUserNotificationsData = {
  /**
   * The ID or username of the user
   */
  idUsername: string;
};

export type GetUserNotificationsResponse = Array<Notification>;

export type GetNotificationData = {
  /**
   * The ID of the notification
   */
  id: string;
};

export type GetNotificationResponse = Notification;

export type ReadNotificationData = {
  /**
   * The ID of the notification
   */
  id: string;
};

export type ReadNotificationResponse = void;

export type DeleteNotificationData = {
  /**
   * The ID of the notification
   */
  id: string;
};

export type DeleteNotificationResponse = void;

export type GetNotificationsData = {
  /**
   * The IDs of the notifications
   */
  ids: string;
};

export type GetNotificationsResponse = Array<Notification>;

export type ReadNotificationsData = {
  /**
   * The IDs of the notifications
   */
  ids: string;
};

export type ReadNotificationsResponse = void;

export type DeleteNotificationsData = {
  /**
   * The IDs of the notifications
   */
  ids: string;
};

export type DeleteNotificationsResponse = void;

export type SubmitReportData = {
  /**
   * The report to be sent
   */
  requestBody?: CreatableReport;
};

export type SubmitReportResponse = Report;

export type GetOpenReportsData = {
  count?: number;
};

export type GetOpenReportsResponse = Array<Report>;

export type GetReportData = {
  /**
   * The ID of the report
   */
  id: string;
};

export type GetReportResponse = Report;

export type ModifyReportData = {
  /**
   * The ID of the report
   */
  id: string;
  /**
   * What to modify about the report
   */
  requestBody?: {
    /**
     * The contents of the report
     */
    body?: string;
    /**
     * Whether the thread should be closed
     */
    closed?: boolean;
  };
};

export type ModifyReportResponse = void;

export type GetReportsData = {
  /**
   * The IDs of the reports
   */
  ids: string;
};

export type GetReportsResponse = Array<Report>;

export type GetThreadData = {
  /**
   * The ID of the thread
   */
  id: string;
};

export type GetThreadResponse = Thread;

export type SendThreadMessageData = {
  /**
   * The ID of the thread
   */
  id: string;
  /**
   * The message to be sent. Note that you only need the fields applicable for the `text` type.
   */
  requestBody?: ThreadMessageBody;
};

export type SendThreadMessageResponse = Thread;

export type GetThreadsData = {
  /**
   * The IDs of the threads
   */
  ids: string;
};

export type GetThreadsResponse = Array<Thread>;

export type DeleteThreadMessageData = {
  /**
   * The ID of the message
   */
  id: string;
};

export type DeleteThreadMessageResponse = void;

export type GetProjectTeamMembersData = {
  /**
   * The ID or slug of the project
   */
  idSlug: string;
};

export type GetProjectTeamMembersResponse = Array<TeamMember>;

export type GetTeamMembersData = {
  /**
   * The ID of the team
   */
  id: string;
};

export type GetTeamMembersResponse = Array<TeamMember>;

export type AddTeamMemberData = {
  /**
   * The ID of the team
   */
  id: string;
  /**
   * User to be added (must be the ID, usernames cannot be used here)
   */
  requestBody?: UserIdentifier;
};

export type AddTeamMemberResponse = void;

export type GetTeamsData = {
  /**
   * The IDs of the teams
   */
  ids: string;
};

export type GetTeamsResponse = Array<Array<TeamMember>>;

export type JoinTeamData = {
  /**
   * The ID of the team
   */
  id: string;
};

export type JoinTeamResponse = void;

export type ModifyTeamMemberData = {
  /**
   * The ID of the team
   */
  id: string;
  /**
   * The ID or username of the user
   */
  idUsername: string;
  /**
   * Contents to be modified
   */
  requestBody?: ModifyTeamMemberBody;
};

export type ModifyTeamMemberResponse = void;

export type DeleteTeamMemberData = {
  /**
   * The ID of the team
   */
  id: string;
  /**
   * The ID or username of the user
   */
  idUsername: string;
};

export type DeleteTeamMemberResponse = void;

export type TransferTeamOwnershipData = {
  /**
   * The ID of the team
   */
  id: string;
  /**
   * New owner's ID
   */
  requestBody?: UserIdentifier;
};

export type TransferTeamOwnershipResponse = void;

export type CategoryListResponse = Array<CategoryTag>;

export type LoaderListResponse = Array<LoaderTag>;

export type VersionListResponse = Array<GameVersionTag>;

export type LicenseListResponse = Array<LicenseTag>;

export type LicenseTextData = {
  /**
   * The license ID to get the text of
   */
  id: string;
};

export type LicenseTextResponse = License;

export type DonationPlatformListResponse = Array<DonationPlatformTag>;

export type ReportTypeListResponse = Array<string>;

export type ProjectTypeListResponse = Array<string>;

export type SideTypeListResponse = Array<string>;

export type ForgeUpdatesData = {
  /**
   * The ID or slug of the project
   */
  idSlug: string;
};

export type ForgeUpdatesResponse = ForgeUpdates;

export type StatisticsResponse = Statistics;

export type $OpenApiTs = {
  "/search": {
    get: {
      req: {
        /**
         * Facets are an essential concept for understanding how to filter out results.
         *
         * These are the most commonly used facet types:
         * - `project_type`
         * - `categories` (loaders are lumped in with categories in search)
         * - `versions`
         * - `client_side`
         * - `server_side`
         * - `open_source`
         *
         * Several others are also available for use, though these should not be used outside very specific use cases.
         * - `title`
         * - `author`
         * - `follows`
         * - `project_id`
         * - `license`
         * - `downloads`
         * - `color`
         * - `created_timestamp`
         * - `modified_timestamp`
         *
         * In order to then use these facets, you need a value to filter by, as well as an operation to perform on this value.
         * The most common operation is `:` (same as `=`), though you can also use `!=`, `>=`, `>`, `<=`, and `<`.
         * Join together the type, operation, and value, and you've got your string.
         * ```
         * {type} {operation} {value}
         * ```
         *
         * Examples:
         * ```
         * categories = adventure
         * versions != 1.20.1
         * downloads <= 100
         * ```
         *
         * You then join these strings together in arrays to signal `AND` and `OR` operators.
         *
         * ##### OR
         * All elements in a single array are considered to be joined by OR statements.
         * For example, the search `[["versions:1.16.5", "versions:1.17.1"]]` translates to `Projects that support 1.16.5 OR 1.17.1`.
         *
         * ##### AND
         * Separate arrays are considered to be joined by AND statements.
         * For example, the search `[["versions:1.16.5"], ["project_type:modpack"]]` translates to `Projects that support 1.16.5 AND are modpacks`.
         *
         */
        facets?: string;
        /**
         * The sorting method used for sorting search results
         */
        index?: "relevance" | "downloads" | "follows" | "newest" | "updated";
        /**
         * The number of results returned by the search
         */
        limit?: number;
        /**
         * The offset into the search. Skips this number of results
         */
        offset?: number;
        /**
         * The query to search for
         */
        query?: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        200: SearchResults;
        /**
         * Request was invalid, see given error
         */
        400: InvalidInputError;
      };
    };
  };
  "/project/{id|slug}": {
    get: {
      req: {
        /**
         * The ID or slug of the project
         */
        idSlug: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        200: Project;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
    patch: {
      req: {
        /**
         * The ID or slug of the project
         */
        idSlug: string;
        /**
         * Modified project fields
         */
        requestBody?: EditableProject;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        204: void;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
    delete: {
      req: {
        /**
         * The ID or slug of the project
         */
        idSlug: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        204: void;
        /**
         * Request was invalid, see given error
         */
        400: InvalidInputError;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
      };
    };
  };
  "/projects": {
    get: {
      req: {
        /**
         * The IDs and/or slugs of the projects
         */
        ids: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        200: Array<Project>;
      };
    };
    patch: {
      req: {
        /**
         * The IDs and/or slugs of the projects
         */
        ids: string;
        /**
         * Fields to edit on all projects specified
         */
        requestBody?: PatchProjectsBody;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        204: void;
        /**
         * Request was invalid, see given error
         */
        400: InvalidInputError;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
      };
    };
  };
  "/projects_random": {
    get: {
      req: {
        /**
         * The number of random projects to return
         */
        count: number;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        200: Array<Project>;
        /**
         * Request was invalid, see given error
         */
        400: InvalidInputError;
      };
    };
  };
  "/project": {
    post: {
      req: {
        /**
         * New project
         */
        formData?: CreateProjectBody;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        200: Project;
        /**
         * Request was invalid, see given error
         */
        400: InvalidInputError;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
      };
    };
  };
  "/project/{id|slug}/icon": {
    patch: {
      req: {
        /**
         * Image extension
         */
        ext:
          | "png"
          | "jpg"
          | "jpeg"
          | "bmp"
          | "gif"
          | "webp"
          | "svg"
          | "svgz"
          | "rgb";
        /**
         * The ID or slug of the project
         */
        idSlug: string;
        requestBody?: Blob | File;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        204: void;
        /**
         * Request was invalid, see given error
         */
        400: InvalidInputError;
      };
    };
    delete: {
      req: {
        /**
         * The ID or slug of the project
         */
        idSlug: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        204: void;
        /**
         * Request was invalid, see given error
         */
        400: InvalidInputError;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
      };
    };
  };
  "/project/{id|slug}/check": {
    get: {
      req: {
        /**
         * The ID or slug of the project
         */
        idSlug: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        200: ProjectIdentifier;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
  };
  "/project/{id|slug}/gallery": {
    post: {
      req: {
        /**
         * Description of the image
         */
        description?: string;
        /**
         * Image extension
         */
        ext:
          | "png"
          | "jpg"
          | "jpeg"
          | "bmp"
          | "gif"
          | "webp"
          | "svg"
          | "svgz"
          | "rgb";
        /**
         * Whether an image is featured
         */
        featured: boolean;
        /**
         * The ID or slug of the project
         */
        idSlug: string;
        /**
         * Ordering of the image
         */
        ordering?: number;
        requestBody?: Blob | File;
        /**
         * Title of the image
         */
        title?: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        204: void;
        /**
         * Request was invalid, see given error
         */
        400: InvalidInputError;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
    patch: {
      req: {
        /**
         * New description of the image
         */
        description?: string;
        /**
         * Whether the image is featured
         */
        featured?: boolean;
        /**
         * The ID or slug of the project
         */
        idSlug: string;
        /**
         * New ordering of the image
         */
        ordering?: number;
        /**
         * New title of the image
         */
        title?: string;
        /**
         * URL link of the image to modify
         */
        url: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        204: void;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
    delete: {
      req: {
        /**
         * The ID or slug of the project
         */
        idSlug: string;
        /**
         * URL link of the image to delete
         */
        url: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        204: void;
        /**
         * Request was invalid, see given error
         */
        400: InvalidInputError;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
      };
    };
  };
  "/project/{id|slug}/dependencies": {
    get: {
      req: {
        /**
         * The ID or slug of the project
         */
        idSlug: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        200: ProjectDependencyList;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
  };
  "/project/{id|slug}/follow": {
    post: {
      req: {
        /**
         * The ID or slug of the project
         */
        idSlug: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        204: void;
        /**
         * Request was invalid, see given error
         */
        400: InvalidInputError;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
      };
    };
    delete: {
      req: {
        /**
         * The ID or slug of the project
         */
        idSlug: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        204: void;
        /**
         * Request was invalid, see given error
         */
        400: InvalidInputError;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
      };
    };
  };
  "/project/{id|slug}/schedule": {
    post: {
      req: {
        /**
         * The ID or slug of the project
         */
        idSlug: string;
        /**
         * Information about date and requested status
         */
        requestBody?: Schedule;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        204: void;
        /**
         * Request was invalid, see given error
         */
        400: InvalidInputError;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
      };
    };
  };
  "/project/{id|slug}/version": {
    get: {
      req: {
        /**
         * Allows to filter for featured or non-featured versions only
         */
        featured?: boolean;
        /**
         * The game versions to filter for
         */
        gameVersions?: string;
        /**
         * The ID or slug of the project
         */
        idSlug: string;
        /**
         * The types of loaders to filter for
         */
        loaders?: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        200: Array<Version>;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
  };
  "/version/{id}": {
    get: {
      req: {
        /**
         * The ID of the version
         */
        id: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        200: Version;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
    patch: {
      req: {
        /**
         * The ID of the version
         */
        id: string;
        /**
         * Modified version fields
         */
        requestBody?: EditableVersion;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        204: void;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
    delete: {
      req: {
        /**
         * The ID of the version
         */
        id: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        204: void;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
  };
  "/project/{id|slug}/version/{id|number}": {
    get: {
      req: {
        /**
         * The version ID or version number
         */
        idNumber: string;
        /**
         * The ID or slug of the project
         */
        idSlug: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        200: Version;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
  };
  "/version": {
    post: {
      req: {
        /**
         * New version
         */
        formData?: CreateVersionBody;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        200: Version;
        /**
         * Request was invalid, see given error
         */
        400: InvalidInputError;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
      };
    };
  };
  "/version/{id}/schedule": {
    post: {
      req: {
        /**
         * The ID of the version
         */
        id: string;
        /**
         * Information about date and requested status
         */
        requestBody?: Schedule;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        204: void;
        /**
         * Request was invalid, see given error
         */
        400: InvalidInputError;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
      };
    };
  };
  "/versions": {
    get: {
      req: {
        /**
         * The IDs of the versions
         */
        ids: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        200: Array<Version>;
      };
    };
  };
  "/version/{id}/file": {
    post: {
      req: {
        /**
         * New version files
         */
        formData?: {
          data?: {
            [key: string]: unknown;
          };
        };
        /**
         * The ID of the version
         */
        id: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        204: void;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
  };
  "/version_file/{hash}": {
    get: {
      req: {
        /**
         * The algorithm of the hash
         */
        algorithm: "sha1" | "sha512";
        /**
         * The hash of the file, considering its byte content, and encoded in hexadecimal
         */
        hash: string;
        /**
         * Whether to return multiple results when looking for this hash
         */
        multiple?: boolean;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        200: Version;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
    delete: {
      req: {
        /**
         * The algorithm of the hash
         */
        algorithm: "sha1" | "sha512";
        /**
         * The hash of the file, considering its byte content, and encoded in hexadecimal
         */
        hash: string;
        /**
         * Version ID to delete the version from, if multiple files of the same hash exist
         */
        versionId?: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        204: void;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
  };
  "/version_file/{hash}/update": {
    post: {
      req: {
        /**
         * The algorithm of the hash
         */
        algorithm: "sha1" | "sha512";
        /**
         * The hash of the file, considering its byte content, and encoded in hexadecimal
         */
        hash: string;
        /**
         * Parameters of the updated version requested
         */
        requestBody?: GetLatestVersionFromHashBody;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        200: Version;
        /**
         * Request was invalid, see given error
         */
        400: unknown;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
  };
  "/version_files": {
    post: {
      req: {
        /**
         * Hashes and algorithm of the versions requested
         */
        requestBody?: HashList;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        200: HashVersionMap;
        /**
         * Request was invalid, see given error
         */
        400: unknown;
      };
    };
  };
  "/version_files/update": {
    post: {
      req: {
        /**
         * Parameters of the updated version requested
         */
        requestBody?: GetLatestVersionsFromHashesBody;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        200: HashVersionMap;
        /**
         * Request was invalid, see given error
         */
        400: unknown;
      };
    };
  };
  "/user/{id|username}": {
    get: {
      req: {
        /**
         * The ID or username of the user
         */
        idUsername: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        200: User;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
    patch: {
      req: {
        /**
         * The ID or username of the user
         */
        idUsername: string;
        /**
         * Modified user fields
         */
        requestBody?: EditableUser;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        204: void;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
  };
  "/user": {
    get: {
      res: {
        /**
         * Expected response to a valid request
         */
        200: User;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
      };
    };
  };
  "/users": {
    get: {
      req: {
        /**
         * The IDs of the users
         */
        ids: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        200: Array<User>;
      };
    };
  };
  "/user/{id|username}/icon": {
    patch: {
      req: {
        /**
         * The ID or username of the user
         */
        idUsername: string;
        requestBody?: Blob | File;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        204: void;
        /**
         * Request was invalid, see given error
         */
        400: InvalidInputError;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
  };
  "/user/{id|username}/projects": {
    get: {
      req: {
        /**
         * The ID or username of the user
         */
        idUsername: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        200: Array<Project>;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
  };
  "/user/{id|username}/follows": {
    get: {
      req: {
        /**
         * The ID or username of the user
         */
        idUsername: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        200: Array<Project>;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
  };
  "/user/{id|username}/payouts": {
    get: {
      req: {
        /**
         * The ID or username of the user
         */
        idUsername: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        200: UserPayoutHistory;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
    post: {
      req: {
        /**
         * Amount to withdraw
         */
        amount: number;
        /**
         * The ID or username of the user
         */
        idUsername: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        204: void;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
  };
  "/user/{id|username}/notifications": {
    get: {
      req: {
        /**
         * The ID or username of the user
         */
        idUsername: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        200: Array<Notification>;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
  };
  "/notification/{id}": {
    get: {
      req: {
        /**
         * The ID of the notification
         */
        id: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        200: Notification;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
    patch: {
      req: {
        /**
         * The ID of the notification
         */
        id: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        204: void;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
    delete: {
      req: {
        /**
         * The ID of the notification
         */
        id: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        204: void;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
  };
  "/notifications": {
    get: {
      req: {
        /**
         * The IDs of the notifications
         */
        ids: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        200: Array<Notification>;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
    patch: {
      req: {
        /**
         * The IDs of the notifications
         */
        ids: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        204: void;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
    delete: {
      req: {
        /**
         * The IDs of the notifications
         */
        ids: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        204: void;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
  };
  "/report": {
    post: {
      req: {
        /**
         * The report to be sent
         */
        requestBody?: CreatableReport;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        200: Report;
        /**
         * Request was invalid, see given error
         */
        400: InvalidInputError;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
      };
    };
    get: {
      req: {
        count?: number;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        200: Array<Report>;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
  };
  "/report/{id}": {
    get: {
      req: {
        /**
         * The ID of the report
         */
        id: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        200: Report;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
    patch: {
      req: {
        /**
         * The ID of the report
         */
        id: string;
        /**
         * What to modify about the report
         */
        requestBody?: {
          /**
           * The contents of the report
           */
          body?: string;
          /**
           * Whether the thread should be closed
           */
          closed?: boolean;
        };
      };
      res: {
        /**
         * Expected response to a valid request
         */
        204: void;
        /**
         * Request was invalid, see given error
         */
        400: InvalidInputError;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
  };
  "/reports": {
    get: {
      req: {
        /**
         * The IDs of the reports
         */
        ids: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        200: Array<Report>;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
  };
  "/thread/{id}": {
    get: {
      req: {
        /**
         * The ID of the thread
         */
        id: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        200: Thread;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
    post: {
      req: {
        /**
         * The ID of the thread
         */
        id: string;
        /**
         * The message to be sent. Note that you only need the fields applicable for the `text` type.
         */
        requestBody?: ThreadMessageBody;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        200: Thread;
        /**
         * Request was invalid, see given error
         */
        400: InvalidInputError;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
  };
  "/threads": {
    get: {
      req: {
        /**
         * The IDs of the threads
         */
        ids: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        200: Array<Thread>;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
  };
  "/message/{id}": {
    delete: {
      req: {
        /**
         * The ID of the message
         */
        id: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        204: void;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
  };
  "/project/{id|slug}/members": {
    get: {
      req: {
        /**
         * The ID or slug of the project
         */
        idSlug: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        200: Array<TeamMember>;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
  };
  "/team/{id}/members": {
    get: {
      req: {
        /**
         * The ID of the team
         */
        id: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        200: Array<TeamMember>;
      };
    };
    post: {
      req: {
        /**
         * The ID of the team
         */
        id: string;
        /**
         * User to be added (must be the ID, usernames cannot be used here)
         */
        requestBody?: UserIdentifier;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        204: void;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
  };
  "/teams": {
    get: {
      req: {
        /**
         * The IDs of the teams
         */
        ids: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        200: Array<Array<TeamMember>>;
      };
    };
  };
  "/team/{id}/join": {
    post: {
      req: {
        /**
         * The ID of the team
         */
        id: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        204: void;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
  };
  "/team/{id}/members/{id|username}": {
    patch: {
      req: {
        /**
         * The ID of the team
         */
        id: string;
        /**
         * The ID or username of the user
         */
        idUsername: string;
        /**
         * Contents to be modified
         */
        requestBody?: ModifyTeamMemberBody;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        204: void;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
    delete: {
      req: {
        /**
         * The ID of the team
         */
        id: string;
        /**
         * The ID or username of the user
         */
        idUsername: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        204: void;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
  };
  "/team/{id}/owner": {
    patch: {
      req: {
        /**
         * The ID of the team
         */
        id: string;
        /**
         * New owner's ID
         */
        requestBody?: UserIdentifier;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        204: void;
        /**
         * Incorrect token scopes or no authorization to access the requested item(s)
         */
        401: AuthError;
        /**
         * The requested item(s) were not found or no authorization to access the requested item(s)
         */
        404: unknown;
      };
    };
  };
  "/tag/category": {
    get: {
      res: {
        /**
         * Expected response to a valid request
         */
        200: Array<CategoryTag>;
      };
    };
  };
  "/tag/loader": {
    get: {
      res: {
        /**
         * Expected response to a valid request
         */
        200: Array<LoaderTag>;
      };
    };
  };
  "/tag/game_version": {
    get: {
      res: {
        /**
         * Expected response to a valid request
         */
        200: Array<GameVersionTag>;
      };
    };
  };
  "/tag/license": {
    get: {
      res: {
        /**
         * Expected response to a valid request
         */
        200: Array<LicenseTag>;
      };
    };
  };
  "/tag/license/{id}": {
    get: {
      req: {
        /**
         * The license ID to get the text of
         */
        id: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        200: License;
        /**
         * Request was invalid, see given error
         */
        400: InvalidInputError;
      };
    };
  };
  "/tag/donation_platform": {
    get: {
      res: {
        /**
         * Expected response to a valid request
         */
        200: Array<DonationPlatformTag>;
      };
    };
  };
  "/tag/report_type": {
    get: {
      res: {
        /**
         * Expected response to a valid request
         */
        200: Array<string>;
      };
    };
  };
  "/tag/project_type": {
    get: {
      res: {
        /**
         * Expected response to a valid request
         */
        200: Array<string>;
      };
    };
  };
  "/tag/side_type": {
    get: {
      res: {
        /**
         * Expected response to a valid request
         */
        200: Array<string>;
      };
    };
  };
  "/updates/{id|slug}/forge_updates.json": {
    get: {
      req: {
        /**
         * The ID or slug of the project
         */
        idSlug: string;
      };
      res: {
        /**
         * Expected response to a valid request
         */
        200: ForgeUpdates;
        /**
         * Invalid request
         */
        400: InvalidInputError;
      };
    };
  };
  "/statistics": {
    get: {
      res: {
        /**
         * Expected response to a valid request
         */
        200: Statistics;
      };
    };
  };
};
